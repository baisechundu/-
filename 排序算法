#快速排序法
class quick_sort(): 
    def splitpoint(self, nums, start, end): #找出分隔点，即本代码中nums[start]在数组中的实际位置，注意end是可以取到的index值
        key = nums[start]
        leftmark = start + 1
        rightmark = end
        done = False
        while not done:
            while nums[leftmark] <= key and leftmark <= rightmark and leftmark < end:
                leftmark += 1
            while nums[rightmark] >= key and leftmark <= rightmark and rightmark > start:
               rightmark -= 1
            if leftmark >= rightmark:     #此处必须是等号，可以用长度为2的数组验证。
                done = True
            else:
                nums[leftmark], nums[rightmark] = nums[rightmark], nums[leftmark]
        nums[start], nums[rightmark] = nums[rightmark], nums[start]
        return rightmark

    def quicksorthelper(self, nums, start, end): 
        if start < end:
            split = self.splitpoint(nums, start, end)
            self.quicksorthelper(nums, start, split - 1)
            self.quicksorthelper(nums, split + 1, end)

    def quicksort(self, nums): 
        self.quicksorthelper(nums, 0, len(nums) - 1)
        return nums
        
if __name__ == '__main__':
    s = quick_sort()
    print(s.quicksort([1,4,6,2,7,3,6,3]))
    
#插入排序
def insertsort(nums):
    if not nums:
        return nums
    length = len(nums)
    for i in range(1,length):
        key = nums[i]
        while i > 0 and nums[i-1] > key:
            nums[i] = nums[i-1]
            i -= 1
        nums[i] = key
    return nums
print(insertsort([1,4,6,2,7,3]))
print(insertsort([]))
print(insertsort([3]))

#冒泡排序
def bubblesort(nums):
    if not nums:
        return nums
    length = len(nums)
    for i in range(length):
        for j in range(1,length-i):
            if nums[j-1] > nums[j]:
                nums[j-1],nums[j] = nums[j], nums[j-1]
    return nums
print(bubblesort([1,4,6,2,7,3]))
print(bubblesort([]))
print(bubblesort([3]))

#短冒泡排序具有识别排序数组的优点，一旦数组已排好序，直接返回即可。
def short_bubblesort(nums):
    if not nums:
        return nums
    length = len(nums)
    sorted = True
    while length > 0 and sorted:
        sorted = False
        for j in range(1,length):
                if nums[j - 1] > nums[j] and sorted:
                    sorted = True
                    nums[j - 1], nums[j] = nums[j], nums[j - 1]
    return nums

print(bubblesort([1,4,6,2,7,3]))
print(bubblesort([]))
print(bubblesort([3]))
print(bubblesort([1,2,3,4,5,6,7,8]))

#选择排序
def selectsort(nums):
    if not nums:
        return nums
    length = len(nums)
    for i in range(length):
        max = nums[0]
        for j in range(length-i):
            if nums[j] >= max:
                max = nums[j]
                position = j
        nums[position], nums[length-i-1] = nums[length-i-1], nums[position]
    return nums
print(selectsort([1,4,6,2,7,3]))
print(selectsort([]))
print(selectsort([3]))

#归并排序（较为冗长，下面可部分优化）
def mergesort_v1(nums):
    length = len(nums)
    if length >1:
        mid = length//2
        left = nums[:mid]
        right = nums[mid:]
        mergesort_v1(left)
        mergesort_v1(right)
        i, j, k = 0, 0, 0
        while len(left) > i and len(right) > j:
            if left[i] < right[j]:
                nums[k] = left[i]
                i += 1
            else:
                 nums[k] = right[j]
                 j += 1
            k += 1
        while len(left) > i:
            nums[k] = left[i]
            i += 1
            k += 1
        while len(right) > j:
            nums[k] = right[j]
            j += 1
            k += 1
    return nums
print(mergesort_v1([1,4,6,2,7,3]))
print(mergesort_v1([]))
print(mergesort_v1([3]))

